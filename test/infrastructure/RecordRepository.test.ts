import { Record } from "../../src/domain/Record";
import { db } from "../../src/infrastructure/FirebaseConfig";
import { RecordRepository } from "../../src/infrastructure/RecordRepository";

describe('RecordRepository', () => {

    it('should create a new record with valid data', async () => {
      const mockRecord = new Record('1', 'Test Record', 1, new Date());
      const mockCreate = jest.fn();
      const mockDoc = jest.fn(() => ({ create: mockCreate }));
      const mockCollection = jest.fn(() => ({ doc: mockDoc }));
      jest.spyOn(db, 'collection').mockReturnValue(mockCollection() as any);

      await RecordRepository.create(mockRecord);

      expect(mockDoc).toHaveBeenCalledWith('1');
      expect(mockCreate).toHaveBeenCalledWith({
        name: 'Test Record',
        incrementId: 1,
        createdAt: mockRecord.createdAt,
        updatedAt: mockRecord.updatedAt
      });
    });

    it('should return null when no records exist', async () => {
      const mockGet = jest.fn(() => ({ docs: [] }));
      const mockOrderBy = jest.fn(() => ({ limit: jest.fn(() => ({ get: mockGet })) }));
      jest.spyOn(db, 'collection').mockReturnValue({ orderBy: mockOrderBy } as any);

      const result = await RecordRepository.getLastRecord();

      expect(mockOrderBy).toHaveBeenCalledWith('incrementId', 'desc');
      expect(mockGet).toHaveBeenCalled();
      expect(result).toBeNull();
    });

    it('should throw an error when creating a new record with invalid data', async () => {
      const mockRecord = new Record('', '', 1, new Date()); // Invalid data with empty name
      const mockCreate = jest.fn();
      const mockDoc = jest.fn(() => ({ create: mockCreate }));
      const mockCollection = jest.fn(() => ({ doc: mockDoc }));
      jest.spyOn(db, 'collection').mockImplementation(() => {
        throw new Error('Unexpected error');
      });

      await expect(RecordRepository.create(mockRecord)).rejects.toThrow();
    });

    // Generated by CodiumAI

describe('update', () => {

  it('should update incrementId and updatedAt fields when record exists', async () => {
      const mockSet = jest.fn();
      const mockDoc = jest.fn(() => ({ set: mockSet }));
      const mockCollection = jest.fn(() => ({ doc: mockDoc }));
      jest.spyOn(db, 'collection').mockReturnValue(mockCollection() as any);

      const id = 'existingRecordId';
      const incrementId = 1;
      await RecordRepository.update(id, incrementId);

      expect(mockDoc).toHaveBeenCalledWith(id);
      expect(mockSet).toHaveBeenCalledWith(
          { incrementId: incrementId, updatedAt: expect.any(Date) },
          { merge: true }
      );
  });

  it('should attempt to update a non-existent record', async () => {
      const mockSet = jest.fn().mockRejectedValue(new Error('Record does not exist'));
      const mockDoc = jest.fn(() => ({ set: mockSet }));
      const mockCollection = jest.fn(() => ({ doc: mockDoc }));
      (db.collection as jest.Mock).mockReturnValue(mockCollection() as any);

      const id = 'nonExistentRecordId';
      const incrementId = 1;
  
      await expect(RecordRepository.update(id, incrementId)).rejects.toThrow('Record does not exist');

      expect(mockDoc).toHaveBeenCalledWith(id);
      expect(mockSet).toHaveBeenCalledWith(
          { incrementId: incrementId, updatedAt: expect.any(Date) },
          { merge: true }
      );
    });
  });

});
